{% extends 'base.html' %}
{% load patient_extras %}

{% block title %}{{ patient.first_name }} {{ patient.last_name }} - Image Annotation{% endblock %}

{% block extra_css %}
<style>
    .annotation-container {
        position: relative;
        margin: 20px 0;
    }
    .canvas-container {
        margin: 0 auto;
        border: 1px solid #ddd;
    }
    .annotation-tools {
        margin-top: 10px;
    }
    .color-picker {
        width: 40px;
        height: 40px;
        padding: 0;
        border: none;
        margin-right: 10px;
    }
    .measurement-field {
        margin-bottom: 10px;
    }
    .measurement-field label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
    }
    .measurement-field input {
        width: 100%;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    .measurement-field input:focus {
        border-color: #0d6efd;
        outline: none;
    }
    .measurement-group {
        border: 1px solid #eee;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 4px;
    }
    .measurement-group h6 {
        margin-bottom: 15px;
        color: #0d6efd;
    }
    #loading-indicator {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
</style>
{% endblock %}

{% block content %}
<!-- Loading Indicator -->
<div id="loading-indicator">
    <div class="text-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading image...</p>
    </div>
</div>

<div class="container">
    <div class="row mb-4">
        <div class="col">
            <h2>Image Annotation - {{ patient.first_name }} {{ patient.last_name }}</h2>
        </div>
        <div class="col text-end">
            <a href="{% url 'patient-detail' patient.pk %}" class="btn btn-secondary">
                <i class="fas fa-arrow-left me-2"></i>Back to Patient Details
            </a>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        {% if specific_image_id %}
                            Annotate Selected Image
                        {% else %}
                            Available Ultrasound Images
                        {% endif %}
                    </h5>
                </div>
                <div class="card-body">
                    {% if exams %}
                        {% for exam in exams %}
                            {% if exam.images.exists %}
                            <div class="mb-4">
                                <h6>Exam Date: {{ exam.exam_date }} - {{ exam.procedure_type.name }}</h6>
                                {% for image in exam.images.all %}
                                    {% if not specific_image_id or image.id == specific_image_id %}
                                    <div class="annotation-container border p-3">
                                        <div class="text-center">
                                            <canvas id="canvas-{{ image.id }}" width="800" height="600"></canvas>
                                        </div>
                                        <div class="annotation-tools mt-3">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <div class="card">
                                                        <div class="card-header">
                                                            <h5 class="card-title mb-0">Procedure Measurements</h5>
                                                        </div>
                                                        <div class="card-body">
                                                            <div class="mb-3">
                                                                <label class="form-label">Procedure Type:</label>
                                                                <input type="text" class="form-control" value="{{ exam.procedure_type.name }}" readonly>
                                                                <input type="hidden" id="procedure-type-{{ image.id }}" value="{{ exam.procedure_type.name|clean_procedure_type }}">
                                                            </div>
                                                            <div id="procedure-fields-{{ image.id }}">
                                                                <!-- Dynamic fields will be loaded here -->
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="col-md-8">
                                                    <div class="card">
                                                        <div class="card-header">
                                                            <h5 class="card-title mb-0">Annotation Tools</h5>
                                                        </div>
                                                        <div class="card-body">
                                                            <div class="btn-group mb-3">
                                                                <button class="btn btn-primary btn-sm" onclick="enableDrawing('{{ image.id }}')">
                                                                    <i class="fas fa-pencil-alt"></i> Draw
                                                                </button>
                                                                <button class="btn btn-info btn-sm" onclick="enableMeasurement('{{ image.id }}')">
                                                                    <i class="fas fa-ruler"></i> Measure
                                                                </button>
                                                                <button class="btn btn-success btn-sm" onclick="saveAnnotations('{{ image.id }}')">
                                                                    <i class="fas fa-save"></i> Save Measurements
                                                                </button>
                                                                <button class="btn btn-warning btn-sm" onclick="clearAnnotations('{{ image.id }}')">
                                                                    <i class="fas fa-eraser"></i> Clear
                                                                </button>
                                                                <button class="btn btn-secondary btn-sm" onclick="undoLastAnnotation('{{ image.id }}')">
                                                                    <i class="fas fa-undo"></i> Undo
                                                                </button>
                                                            </div>
                                                            <div class="annotation-preview mt-4">
                                                                <h6 class="mb-3">
                                                                    Annotation Preview
                                                                    <button class="btn btn-primary btn-sm float-end" onclick="saveAnnotationPreview('{{ image.id }}')">
                                                                        <i class="fas fa-download"></i> Save Preview
                                                                    </button>
                                                                </h6>
                                                                <div class="card">
                                                                    <div class="card-body">
                                                                        <div class="mb-3">
                                                                            <label for="notes-{{ image.id }}" class="form-label">Notes:</label>
                                                                            <textarea class="form-control" id="notes-{{ image.id }}" rows="3" placeholder="Add any additional notes here..."></textarea>
                                                                        </div>
                                                                        <div id="annotation-preview-{{ image.id }}">
                                                                            <!-- Annotation preview will be displayed here -->
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <input type="hidden" id="image-url-{{ image.id }}" value="{{ image.image.url }}">
                                    </div>
                                    {% endif %}
                                {% endfor %}
                            </div>
                            {% endif %}
                        {% endfor %}
                    {% else %}
                        <p class="text-center">No examinations found for this patient.</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script>
    const canvases = {};
    const measurements = {};
    const undoStack = {};
    let isDrawing = false;
    let isMeasuring = false;
    let startPoint = null;

    // Procedure-specific measurement fields
    const procedureFields = {
        pelvic: [
            { id: 'uterus_length', label: 'Uterus Length (cm)', type: 'measurement' },
            { id: 'uterus_width', label: 'Uterus Width (cm)', type: 'measurement' },
            { id: 'endometrial_thickness', label: 'Endometrial Thickness (mm)', type: 'measurement' },
            { id: 'right_ovary_location', label: 'Right Ovary Location', type: 'location' },
            { id: 'left_ovary_location', label: 'Left Ovary Location', type: 'location' }
        ],
        abdominal: [
            { id: 'liver_size', label: 'Liver Size (cm)', type: 'measurement' },
            { id: 'liver_location', label: 'Liver Location', type: 'location' },
            { id: 'gallbladder_location', label: 'Gallbladder Location', type: 'location' },
            { id: 'spleen_size', label: 'Spleen Size (cm)', type: 'measurement' },
            { id: 'kidney_right_size', label: 'Right Kidney Size (cm)', type: 'measurement' },
            { id: 'kidney_left_size', label: 'Left Kidney Size (cm)', type: 'measurement' }
        ],
        breast: [
            { id: 'mass_location', label: 'Mass Location', type: 'location' },
            { id: 'mass_size', label: 'Mass Size (cm)', type: 'measurement' },
            { id: 'distance_from_nipple', label: 'Distance from Nipple (cm)', type: 'measurement' }
        ],
        thyroid: [
            { id: 'right_lobe_size', label: 'Right Lobe Size (cm)', type: 'measurement' },
            { id: 'left_lobe_size', label: 'Left Lobe Size (cm)', type: 'measurement' },
            { id: 'nodule_location', label: 'Nodule Location', type: 'location' },
            { id: 'nodule_size', label: 'Nodule Size (mm)', type: 'measurement' }
        ],
        prostate: [
            { id: 'prostate_length', label: 'Prostate Length (cm)', type: 'measurement' },
            { id: 'prostate_width', label: 'Prostate Width (cm)', type: 'measurement' },
            { id: 'prostate_height', label: 'Prostate Height (cm)', type: 'measurement' },
            { id: 'prostate_volume', label: 'Prostate Volume (cc)', type: 'measurement' },
            { id: 'prostate_location', label: 'Prostate Location', type: 'location' }
        ],
        obstetric: [
            { id: 'gestational_age', label: 'Gestational Age (weeks)', type: 'measurement' },
            { id: 'crown_rump_length', label: 'Crown-Rump Length (cm)', type: 'measurement' },
            { id: 'biparietal_diameter', label: 'Biparietal Diameter (cm)', type: 'measurement' },
            { id: 'femur_length', label: 'Femur Length (cm)', type: 'measurement' },
            { id: 'amniotic_fluid_index', label: 'Amniotic Fluid Index (cm)', type: 'measurement' }
        ],
        transvaginal: [
            { id: 'uterus_length', label: 'Uterus Length (cm)', type: 'measurement' },
            { id: 'uterus_width', label: 'Uterus Width (cm)', type: 'measurement' },
            { id: 'endometrial_thickness', label: 'Endometrial Thickness (mm)', type: 'measurement' },
            { id: 'right_ovary_size', label: 'Right Ovary Size (cm)', type: 'measurement' },
            { id: 'left_ovary_size', label: 'Left Ovary Size (cm)', type: 'measurement' }
        ],
        scrotal: [
            { id: 'right_testis_length', label: 'Right Testis Length (cm)', type: 'measurement' },
            { id: 'right_testis_width', label: 'Right Testis Width (cm)', type: 'measurement' },
            { id: 'left_testis_length', label: 'Left Testis Length (cm)', type: 'measurement' },
            { id: 'left_testis_width', label: 'Left Testis Width (cm)', type: 'measurement' },
            { id: 'epididymis_location', label: 'Epididymis Location', type: 'location' }
        ],
        doppler: [
            { id: 'peak_systolic_velocity', label: 'Peak Systolic Velocity (cm/s)', type: 'measurement' },
            { id: 'end_diastolic_velocity', label: 'End Diastolic Velocity (cm/s)', type: 'measurement' },
            { id: 'resistive_index', label: 'Resistive Index', type: 'measurement' },
            { id: 'pulsatility_index', label: 'Pulsatility Index', type: 'measurement' }
        ],
        other: [
            { id: 'general_measurements', label: 'General Measurements (cm)', type: 'measurement' },
            { id: 'abnormal_findings', label: 'Abnormal Findings Location', type: 'location' },
            { id: 'additional_notes', label: 'Additional Notes', type: 'text' }
        ]
    };

    document.addEventListener('DOMContentLoaded', function() {
        // Initialize loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (!loadingIndicator) {
            console.error('Loading indicator not found');
            return;
        }

        // Initialize all canvases
        const canvasElements = document.querySelectorAll('[id^="canvas-"]');
        canvasElements.forEach(canvasElement => {
            const imageId = canvasElement.id.split('-')[1];
            try {
                console.log('Initializing canvas for image ' + imageId);
                initCanvas(imageId);
                loadSavedAnnotations(imageId);
                
                // Automatically load procedure fields based on the exam's procedure type
                const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
                if (procedureTypeHidden && procedureTypeHidden.value) {
                    loadProcedureFields(imageId);
                }
            } catch (error) {
                console.error('Error initializing canvas for image ' + imageId + ':', error);
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
            }
        });

        setupDragAndDrop();
        setupFormSubmission();
    });

    function setupDragAndDrop() {
        const dragDropZone = document.getElementById('dragDropZone');
        if (!dragDropZone) return;  // Skip if element doesn't exist

        const imageInput = document.getElementById('imageInput');
        const selectedFileName = document.querySelector('.selected-file-name');
        if (!imageInput || !selectedFileName) return;

        imageInput.addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                selectedFileName.textContent = this.files[0].name;
                previewImage(this.files[0]);
            }
        });

        dragDropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.style.borderColor = '#0d6efd';
        });

        dragDropZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            this.style.borderColor = '#ccc';
        });

        dragDropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            this.style.borderColor = '#ccc';
            
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                imageInput.files = e.dataTransfer.files;
                selectedFileName.textContent = e.dataTransfer.files[0].name;
                previewImage(e.dataTransfer.files[0]);
            }
        });
    }

    function setupFormSubmission() {
        const uploadForm = document.getElementById('uploadForm');
        if (!uploadForm) return;  // Skip if form doesn't exist

        uploadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const imageInput = document.getElementById('imageInput');
            const examSelect = document.getElementById('examSelect');

            if (!imageInput || !imageInput.files || !imageInput.files[0]) {
                alert('Please select an image to upload');
                return;
            }

            if (!examSelect || !examSelect.value) {
                alert('Please select an examination');
                return;
            }

            // Show loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'block';
            }
            
            this.submit();
        });
    }

    function loadSavedAnnotations(imageId) {
        fetch(`/api/exams/${imageId}/annotations/`)
            .then(response => response.json())
            .then(data => {
                if (data.annotations) {
                    const canvas = canvases[imageId];
                    canvas.loadFromJSON(data.annotations, function() {
                        canvas.renderAll();
                        // Restore measurements from saved annotations
                        const objects = canvas.getObjects();
                        measurements[imageId] = {};
                        objects.forEach(obj => {
                            if (obj.type === 'text' && obj.measurementId) {
                                measurements[imageId][obj.measurementId] = obj.text;
                            }
                        });
                        
                        // Restore notes if they exist
                        if (data.notes) {
                            const notesTextarea = document.getElementById(`notes-${imageId}`);
                            if (notesTextarea) {
                                notesTextarea.value = data.notes;
                            }
                        }
                        
                        updateMeasurementSummary(imageId);
                    });
                }
            })
            .catch(error => console.error('Error loading annotations:', error));
    }

    function initCanvas(imageId) {
        const loadingIndicator = document.getElementById('loading-indicator');
        const canvasContainer = document.getElementById(`canvas-${imageId}`);
        
        if (!canvasContainer) {
            console.error(`Canvas container not found for image ${imageId}`);
            return;
        }

        loadingIndicator.style.display = 'block';

        // Dispose of existing canvas if it exists
        if (canvases[imageId]) {
            canvases[imageId].dispose();
        }

        const canvas = new fabric.Canvas(`canvas-${imageId}`, {
            selection: true,
            preserveObjectStacking: true,
            isDrawingMode: false
        });
        
        canvases[imageId] = canvas;
        measurements[imageId] = {};
        undoStack[imageId] = [];
        
        // Load the ultrasound image
        const imageUrl = document.getElementById(`image-url-${imageId}`).value;
        
        fabric.Image.fromURL(imageUrl, function(img) {
            if (!img) {
                console.error(`Failed to load image for ${imageId}`);
                loadingIndicator.style.display = 'none';
                return;
            }

            const scale = Math.min(
                canvas.width / img.width,
                canvas.height / img.height
            );
            
            img.scale(scale);
            canvas.setBackgroundImage(img, function() {
                canvas.renderAll();
                loadingIndicator.style.display = 'none';
            }, {
                originX: 'center',
                originY: 'center',
                left: canvas.width / 2,
                top: canvas.height / 2
            });
        }, null, {
            crossOrigin: 'anonymous'
        });

        // Set up drawing brush
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.width = 2;
        canvas.freeDrawingBrush.color = '#ff0000';

        // Mouse down event
        canvas.on('mouse:down', function(options) {
            if (isMeasuring) {
                startPoint = canvas.getPointer(options.e);
                const circle = new fabric.Circle({
                    radius: 3,
                    fill: '#ff0000',
                    left: startPoint.x,
                    top: startPoint.y,
                    selectable: false,
                    originX: 'center',
                    originY: 'center'
                });
                canvas.add(circle);
            }
        });

        // Mouse move event
        canvas.on('mouse:move', function(options) {
            if (isMeasuring && startPoint) {
                const currentPoint = canvas.getPointer(options.e);
                const objects = canvas.getObjects();
                const lastLine = objects[objects.length - 1];
                
                if (lastLine && lastLine.type === 'line') {
                    canvas.remove(lastLine);
                }

                const line = new fabric.Line([
                    startPoint.x,
                    startPoint.y,
                    currentPoint.x,
                    currentPoint.y
                ], {
                    stroke: '#ff0000',
                    strokeWidth: 2,
                    selectable: true,
                    originX: 'center',
                    originY: 'center'
                });

                // Calculate distance in pixels
                const distance = Math.sqrt(
                    Math.pow(currentPoint.x - startPoint.x, 2) +
                    Math.pow(currentPoint.y - startPoint.y, 2)
                );

                // Add measurement text
                const midPoint = {
                    x: (startPoint.x + currentPoint.x) / 2,
                    y: (startPoint.y + currentPoint.y) / 2
                };

                canvas.add(line);
                canvas.renderAll();
            }
        });

        // Mouse up event
        canvas.on('mouse:up', function(options) {
            if (isMeasuring && startPoint) {
                const endPoint = canvas.getPointer(options.e);
                
                // Calculate distance and convert to appropriate units (assuming 1px = 0.1mm)
                const pixelDistance = Math.sqrt(
                    Math.pow(endPoint.x - startPoint.x, 2) +
                    Math.pow(endPoint.y - startPoint.y, 2)
                );
                const mmDistance = (pixelDistance * 0.1).toFixed(1);
                
                const measurementId = `measurement_${Date.now()}`;
                const text = new fabric.Text(
                    `${mmDistance} mm`,
                    {
                        left: (startPoint.x + endPoint.x) / 2,
                        top: (startPoint.y + endPoint.y) / 2 - 10,
                        fontSize: 14,
                        fill: '#ff0000',
                        selectable: true,
                        measurementId: measurementId,
                        originX: 'center',
                        originY: 'center'
                    }
                );
                canvas.add(text);
                
                // Store measurement
                measurements[imageId][measurementId] = `${mmDistance} mm`;
                
                // Add end point circle
                const circle = new fabric.Circle({
                    radius: 3,
                    fill: '#ff0000',
                    left: endPoint.x,
                    top: endPoint.y,
                    selectable: false,
                    originX: 'center',
                    originY: 'center'
                });
                canvas.add(circle);
                
                startPoint = null;
                saveToUndoStack(imageId);
                updateMeasurementSummary(imageId);
            }
        });

        // Add keyboard event for delete
        document.addEventListener('keyup', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length > 0) {
                    activeObjects.forEach(obj => {
                        canvas.remove(obj);
                        if (obj.measurementId && measurements[imageId]) {
                            delete measurements[imageId][obj.measurementId];
                        }
                    });
                    canvas.discardActiveObject();
                    canvas.renderAll();
                    saveToUndoStack(imageId);
                    updateMeasurementSummary(imageId);
                }
            }
        });

        return canvas;
    }

    function loadProcedureFields(examId) {
        const procedureTypeHidden = document.getElementById(`procedure-type-${examId}`);
        if (!procedureTypeHidden) {
            console.error('Procedure type hidden field not found');
            return;
        }

        // Get and clean up the procedure type value
        let procedureType = procedureTypeHidden.value.toLowerCase()
            .replace(/\s+ultrasound/i, '')  // Remove "ultrasound" and spaces before it
            .replace(/\s+/g, '')  // Remove all spaces
            .trim();
            
        console.log('Procedure type from hidden field:', procedureTypeHidden.value);
        console.log('Cleaned procedure type:', procedureType);
        
        const fieldsContainer = document.getElementById(`procedure-fields-${examId}`);
        if (!fieldsContainer) {
            console.error('Fields container not found');
            return;
        }

        const fields = procedureFields[procedureType] || [];
        console.log('Found fields:', fields);
        
        let html = '';
        fields.forEach(field => {
            html += `
                <div class="mb-3">
                    <label class="form-label">${field.label}:</label>
                    ${field.type === 'location' ? `
                        <div class="input-group">
                            <input type="text" class="form-control" id="${field.id}-${examId}" placeholder="Click on image to set location">
                            <button class="btn btn-outline-primary" onclick="startLocationSelection('${examId}', '${field.id}')">
                                Set Location
                            </button>
                        </div>
                    ` : field.type === 'text' ? `
                        <textarea class="form-control" id="${field.id}-${examId}" rows="2" 
                                  onchange="updateMeasurement('${examId}', '${field.id}', this.value)" 
                                  placeholder="Enter additional notes or findings"></textarea>
                    ` : `
                        <input type="number" class="form-control" id="${field.id}-${examId}" 
                               onchange="updateMeasurement('${examId}', '${field.id}', this.value)">
                    `}
                </div>
            `;
        });
        
        fieldsContainer.innerHTML = html;
        clearAnnotations(examId);
    }

    function loadSavedMeasurements(imageId, procedureType) {
        fetch(`/api/exams/${imageId}/annotations/?type=${procedureType}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data && data.measurements) {
                    Object.entries(data.measurements).forEach(([key, value]) => {
                        const input = document.getElementById(`${key}-${imageId}`);
                        if (input) {
                            input.value = value;
                        }
                    });
                }
            })
            .catch(error => {
                console.log('Warning: Could not load saved measurements.', error);
                // Don't show error to user, just continue without loading measurements
            });
    }

    function updateMeasurement(imageId, fieldId, value) {
        if (!measurements[imageId]) {
            measurements[imageId] = {};
        }
        measurements[imageId][fieldId] = value;
        updateMeasurementSummary(imageId);
    }

    function updateMeasurementSummary(examId) {
        const procedureTypeHidden = document.getElementById(`procedure-type-${examId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        const previewContainer = document.getElementById(`annotation-preview-${examId}`);
        const fields = procedureFields[procedureType.toLowerCase().replace(/\s+ultrasound/i, '').replace(/\s+/g, '').trim()] || [];
        
        // Update annotation preview
        let previewHtml = '';
        if (procedureType) {
            previewHtml += `<h6 class="text-primary">${procedureType}</h6>`;
            
            // Group measurements and locations
            const measurements = fields.filter(f => f.type === 'measurement' && document.getElementById(`${f.id}-${examId}`).value);
            const locations = fields.filter(f => f.type === 'location' && document.getElementById(`${f.id}-${examId}`).value);
            const textFields = fields.filter(f => f.type === 'text' && document.getElementById(`${f.id}-${examId}`).value);
            
            if (measurements.length > 0) {
                previewHtml += '<div class="mb-3"><strong>Measurements:</strong><ul class="mb-0">';
                measurements.forEach(field => {
                    const value = document.getElementById(`${field.id}-${examId}`).value;
                    if (value) {
                        previewHtml += `<li>${field.label}: ${value}</li>`;
                    }
                });
                previewHtml += '</ul></div>';
            }
            
            if (locations.length > 0) {
                previewHtml += '<div><strong>Marked Locations:</strong><ul class="mb-0">';
                locations.forEach(field => {
                    const value = document.getElementById(`${field.id}-${examId}`).value;
                    if (value) {
                        previewHtml += `<li>${field.label}: ${value}</li>`;
                    }
                });
                previewHtml += '</ul></div>';
            }
            
            if (textFields.length > 0) {
                previewHtml += '<div class="mb-3"><strong>Additional Information:</strong><ul class="mb-0">';
                textFields.forEach(field => {
                    const value = document.getElementById(`${f.id}-${examId}`).value;
                    if (value) {
                        previewHtml += `<li>${field.label}: ${value}</li>`;
                    }
                });
                previewHtml += '</ul></div>';
            }

            // Add notes to preview if they exist
            const notes = document.getElementById(`notes-${examId}`).value.trim();
            if (notes) {
                previewHtml += '<div class="mt-3"><strong>Notes:</strong><p class="mb-0">' + notes.replace(/\n/g, '<br>') + '</p></div>';
            }

            if (!measurements.length && !locations.length && !textFields.length && !notes) {
                previewHtml += '<p class="text-muted">No measurements, locations, additional information, or notes marked yet.</p>';
            }
        } else {
            previewHtml = '<p class="text-muted">Please select a procedure type to start annotation.</p>';
        }
        
        previewContainer.innerHTML = previewHtml;
    }

    function clearAnnotations(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;

        // Clear all objects except background image
        const objects = canvas.getObjects();
        objects.forEach(obj => {
            if (obj !== canvas.backgroundImage) {
                canvas.remove(obj);
            }
        });
        canvas.renderAll();
        
        // Clear measurements
        measurements[imageId] = {};
        undoStack[imageId] = [];
        
        // Clear input fields
        const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        if (procedureType) {
            const cleanedProcedureType = procedureType.toLowerCase()
                .replace(/\s+ultrasound/i, '')
                .replace(/\s+/g, '')
                .trim();
            const fields = procedureFields[cleanedProcedureType] || [];
            fields.forEach(field => {
                const input = document.getElementById(`${field.id}-${imageId}`);
                if (input) input.value = '';
            });
        }
        
        updateMeasurementSummary(imageId);
    }

    function saveToUndoStack(imageId) {
        const canvas = canvases[imageId];
        undoStack[imageId].push({
            canvas: JSON.stringify(canvas.toJSON()),
            measurements: JSON.parse(JSON.stringify(measurements[imageId]))
        });
    }

    function undoLastAnnotation(imageId) {
        if (undoStack[imageId].length > 0) {
            const canvas = canvases[imageId];
            const lastState = undoStack[imageId].pop();
            
            canvas.loadFromJSON(JSON.parse(lastState.canvas), function() {
                canvas.renderAll();
                measurements[imageId] = lastState.measurements;
                updateMeasurementSummary(imageId);
            });
        }
    }

    function enableDrawing(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;

        isDrawing = true;
        isMeasuring = false;
        canvas.isDrawingMode = true;
        canvas.freeDrawingBrush.width = 2;
        canvas.freeDrawingBrush.color = '#ff0000';
        
        // Change cursor
        canvas.defaultCursor = 'crosshair';
        canvas.hoverCursor = 'crosshair';
    }

    function enableMeasurement(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;

        isDrawing = false;
        isMeasuring = true;
        canvas.isDrawingMode = false;
        
        // Change cursor
        canvas.defaultCursor = 'crosshair';
        canvas.hoverCursor = 'crosshair';
    }

    function saveAnnotations(imageId) {
        const canvas = canvases[imageId];
        const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        
        if (!procedureType) {
            alert('No procedure type found. Please refresh the page and try again.');
            return;
        }
        
        // Get the cleaned procedure type for field lookup
        const cleanedProcedureType = procedureType.toLowerCase()
            .replace(/\s+ultrasound/i, '')
            .replace(/\s+/g, '')
            .trim();
        
        // Collect all measurements for the current procedure
        const measurementData = {};
        const fields = procedureFields[cleanedProcedureType] || [];
        
        fields.forEach(field => {
            const input = document.getElementById(`${field.id}-${imageId}`);
            if (input && input.value) {
                measurementData[field.id] = input.value;
            }
        });

        // Get notes
        const notes = document.getElementById(`notes-${imageId}`).value.trim();
        
        const data = {
            annotations: canvas.toJSON(['measurementId']),
            measurements: measurementData,
            procedure_type: procedureType,
            notes: notes
        };
        
        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'block';
        }
        
        fetch(`/api/exams/${imageId}/annotations/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            if (data.status === 'success') {
                // Show success message
                const successMessage = document.createElement('div');
                successMessage.className = 'alert alert-success alert-dismissible fade show';
                successMessage.innerHTML = `
                    <strong>Success!</strong> Annotations, measurements, and notes saved successfully.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                `;
                const container = document.querySelector('.annotation-container');
                container.insertBefore(successMessage, container.firstChild);
                
                // Auto dismiss after 3 seconds
                setTimeout(() => {
                    successMessage.remove();
                }, 3000);
                
                updateMeasurementSummary(imageId);
            } else {
                throw new Error('Error saving annotations and measurements');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            // Show error message
            const errorMessage = document.createElement('div');
            errorMessage.className = 'alert alert-danger alert-dismissible fade show';
            errorMessage.innerHTML = `
                <strong>Error!</strong> Failed to save annotations and measurements. Please try again.
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            const container = document.querySelector('.annotation-container');
            container.insertBefore(errorMessage, container.firstChild);
            
            // Auto dismiss after 5 seconds
            setTimeout(() => {
                errorMessage.remove();
            }, 5000);
        });
    }

    // Helper function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function startLocationSelection(examId, fieldId) {
        const canvas = canvases[examId];
        if (!canvas) {
            console.error('Canvas not found');
            return;
        }

        const input = document.getElementById(`${fieldId}-${examId}`);
        if (!input) {
            console.error('Input field not found');
            return;
        }

        // Change cursor to indicate location selection mode
        canvas.defaultCursor = 'crosshair';
        
        // Remove any existing mouse:down handlers
        canvas.off('mouse:down');
        
        // Add new mouse:down handler
        canvas.on('mouse:down', function locationHandler(options) {
            const pointer = canvas.getPointer(options.e);
            addLocationMarker(examId, fieldId, pointer.x, pointer.y);
            input.value = `X: ${Math.round(pointer.x)}, Y: ${Math.round(pointer.y)}`;
            
            // Reset cursor and remove this handler after location is set
            canvas.defaultCursor = 'default';
            canvas.off('mouse:down', locationHandler);
            
            // Update measurements
            updateMeasurement(examId, fieldId, input.value);
        });
    }

    function addLocationMarker(examId, fieldId, x, y) {
        const canvas = canvases[examId];
        if (!canvas) {
            console.error('Canvas not found');
            return;
        }

        // Create marker circle
        const circle = new fabric.Circle({
            left: x - 5,
            top: y - 5,
            radius: 5,
            fill: 'red',
            stroke: 'white',
            strokeWidth: 2,
            selectable: false
        });
        
        // Create label
        const labelText = fieldId.replace(/_/g, ' ').replace(/location$/, '').trim();
        const label = new fabric.Text(labelText, {
            left: x + 10,
            top: y - 10,
            fontSize: 14,
            fill: 'red',
            selectable: false
        });
        
        // Group circle and label
        const group = new fabric.Group([circle, label], {
            id: fieldId,
            selectable: false
        });
        
        // Remove existing marker for this field if it exists
        const existingObjects = canvas.getObjects().filter(obj => obj.id === fieldId);
        existingObjects.forEach(obj => canvas.remove(obj));
        
        // Add new marker
        canvas.add(group);
        canvas.renderAll();
        
        // Save to undo stack
        saveToUndoStack(examId);
    }

    function saveAnnotationPreview(imageId) {
        const canvas = canvases[imageId];
        const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        
        if (!canvas || !procedureType) {
            alert('Please ensure you have an image and procedure type available.');
            return;
        }

        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'block';
        }

        // Get the notes
        const notes = document.getElementById(`notes-${imageId}`).value.trim();

        // Calculate required height for notes
        const lineHeight = 20;
        const noteLines = notes ? notes.split('\n').length : 0;
        const extraHeight = Math.max(150, (noteLines * lineHeight) + 100); // Minimum 150px or more based on notes

        // Create a temporary canvas to combine the image and annotations
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + extraHeight;
        const ctx = tempCanvas.getContext('2d');

        // Clear the entire canvas with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // Draw the main canvas content
        ctx.drawImage(canvas.getElement(), 0, 0);

        // Add white background for text area
        ctx.fillStyle = 'white';
        ctx.fillRect(0, canvas.height, canvas.width, extraHeight);

        // Set text properties
        ctx.fillStyle = 'black';
        ctx.font = '14px Arial';
        
        // Get all measurements and locations
        const cleanedProcedureType = procedureType.toLowerCase()
            .replace(/\s+ultrasound/i, '')
            .replace(/\s+/g, '')
            .trim();
        const fields = procedureFields[cleanedProcedureType] || [];
        let yPos = canvas.height + 30; // Start a bit lower from the image
        
        // Add title
        ctx.font = 'bold 16px Arial';
        ctx.fillText(`${procedureType} Annotations`, 10, yPos);
        yPos += 25;
        ctx.font = '14px Arial';

        // Add measurements
        const measurements = fields.filter(f => f.type === 'measurement' && document.getElementById(`${f.id}-${imageId}`).value);
        if (measurements.length > 0) {
            ctx.fillText('Measurements:', 10, yPos);
            yPos += 20;
            measurements.forEach(field => {
                const value = document.getElementById(`${field.id}-${imageId}`).value;
                if (value) {
                    ctx.fillText(`${field.label}: ${value}`, 20, yPos);
                    yPos += 20;
                }
            });
        }

        // Add locations
        const locations = fields.filter(f => f.type === 'location' && document.getElementById(`${f.id}-${imageId}`).value);
        if (locations.length > 0) {
            yPos += 10;
            ctx.fillText('Marked Locations:', 10, yPos);
            yPos += 20;
            locations.forEach(field => {
                const value = document.getElementById(`${field.id}-${imageId}`).value;
                if (value) {
                    ctx.fillText(`${field.label}: ${value}`, 20, yPos);
                    yPos += 20;
                }
            });
        }

        // Add notes if they exist
        if (notes) {
            yPos += 20;
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Notes:', 10, yPos);
            ctx.font = '14px Arial';
            yPos += 20;
            
            // Split notes into lines and render each line
            const noteLines = notes.split('\n');
            noteLines.forEach(line => {
                // Handle long lines by wrapping text
                const words = line.split(' ');
                let currentLine = '';
                const maxWidth = canvas.width - 40; // Leave some margin

                words.forEach(word => {
                    const testLine = currentLine + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine !== '') {
                        ctx.fillText(currentLine, 20, yPos);
                        currentLine = word + ' ';
                        yPos += lineHeight;
                    } else {
                        currentLine = testLine;
                    }
                });
                
                if (currentLine) {
                    ctx.fillText(currentLine.trim(), 20, yPos);
                    yPos += lineHeight;
                }
            });
        }

        // Convert the canvas to a data URL
        const dataUrl = tempCanvas.toDataURL('image/png');

        // Send to server
        fetch(`/api/exams/${imageId}/save-preview/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                image_data: dataUrl,
                procedure_type: cleanedProcedureType,
                annotations: canvas.toJSON(['measurementId']),
                preview_html: document.getElementById(`annotation-preview-${imageId}`).innerHTML,
                notes: notes
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            
            if (data.status === 'success') {
                // Show brief success message
                const successMessage = document.createElement('div');
                successMessage.className = 'alert alert-success';
                successMessage.textContent = 'Annotation preview saved successfully. Redirecting...';
                document.body.insertBefore(successMessage, document.body.firstChild);
                
                // Redirect to patient detail page after a brief delay
                setTimeout(() => {
                    window.location.href = `/patient/${data.patient_id}/`;
                }, 1500);
            } else {
                throw new Error(data.message || 'Error saving preview');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            
            // Show error message
            const errorMessage = document.createElement('div');
            errorMessage.className = 'alert alert-danger alert-dismissible fade show';
            errorMessage.innerHTML = `
                <strong>Error!</strong> Failed to save annotation preview. Please try again.
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            const container = document.querySelector('.annotation-container');
            container.insertBefore(errorMessage, container.firstChild);

            // Auto dismiss after 5 seconds
            setTimeout(() => {
                errorMessage.remove();
            }, 5000);
        });
    }
</script>
{% endblock %} 