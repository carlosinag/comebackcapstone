{% extends 'base.html' %}
{% load patient_extras %}

{% block title %}{{ patient.first_name }} {{ patient.last_name }} - Image Annotation{% endblock %}

{% block extra_css %}
<style>
    .annotation-container {
        position: relative;
        margin: 20px 0;
    }
    .canvas-container {
        margin: 0 auto;
        border: 1px solid #ddd;
    }
    .annotation-tools {
        margin-top: 10px;
    }
    .color-picker {
        width: 40px;
        height: 40px;
        padding: 0;
        border: none;
        margin-right: 10px;
    }
    .measurement-field {
        margin-bottom: 10px;
    }
    .measurement-field label {
        display: block;
        margin-bottom: 5px;
        font-weight: 500;
    }
    .measurement-field input {
        width: 100%;
        padding: 5px;
        border: 1px solid #ddd;
        border-radius: 4px;
    }
    .measurement-field input:focus {
        border-color: #0d6efd;
        outline: none;
    }
    .measurement-group {
        border: 1px solid #eee;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 4px;
    }
    .measurement-group h6 {
        margin-bottom: 15px;
        color: #0d6efd;
    }
    #loading-indicator {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
        background: rgba(255, 255, 255, 0.9);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
</style>
{% endblock %}

{% block content %}
<!-- Loading Indicator -->
<div id="loading-indicator">
    <div class="text-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-2">Loading image...</p>
    </div>
</div>

<div class="container">
    <div class="row mb-4">
        <div class="col">
            <h2>Image Annotation - {{ patient.first_name }} {{ patient.last_name }}</h2>
        </div>
        <div class="col text-end">
            <a href="{% url 'patient-detail' patient.pk %}" class="btn btn-secondary">
                <i class="fas fa-arrow-left me-2"></i>Back to Patient Details
            </a>
        </div>
    </div>

    <div class="row">
        <div class="col-md-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        {% if specific_image_id %}
                            Annotate Selected Image
                        {% else %}
                            Available Ultrasound Images
                        {% endif %}
                    </h5>
                </div>
                <div class="card-body">
                    {% if exams %}
                        {% for exam in exams %}
                            {% if exam.images.exists %}
                            <div class="mb-4">
                                <h6>Exam Date: {{ exam.exam_date }} - {{ exam.procedure_type.name }}</h6>
                                {% for image in exam.images.all %}
                                    {% if not specific_image_id or image.id == specific_image_id %}
                                    <div class="annotation-container border p-3">
                                        <div class="text-center">
                                            <canvas id="canvas-{{ image.id }}" width="800" height="600"></canvas>
                                        </div>
                                        <div class="annotation-tools mt-3">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <div class="card">
                                                        <div class="card-header">
                                                            <h5 class="card-title mb-0">Procedure Measurements</h5>
                                                        </div>
                                                        <div class="card-body">
                                                            <div class="mb-3">
                                                                <label class="form-label">Procedure Type:</label>
                                                                <input type="text" class="form-control" value="{{ exam.procedure_type.name }}" readonly>
                                                                <input type="hidden" id="procedure-type-{{ image.id }}" value="{{ exam.procedure_type.name|clean_procedure_type }}">
                                                            </div>
                                                            <div id="procedure-fields-{{ image.id }}">
                                                                <!-- Dynamic fields will be loaded here -->
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="col-md-8">
                                                    <div class="card">
                                                        <div class="card-header">
                                                            <h5 class="card-title mb-0">Annotation Tools</h5>
                                                        </div>
                                                        <div class="card-body">
                                                            <div class="btn-toolbar mb-3" role="toolbar" aria-label="Annotation toolbar">
                                                                <div class="btn-group me-2" role="group" aria-label="Modes">
                                                                    <button class="btn btn-outline-primary btn-sm" onclick="enableDrawing('{{ image.id }}')" title="Freehand draw">
                                                                        <i class="fas fa-pencil-alt me-1"></i>Draw
                                                                    </button>
                                                                    <button class="btn btn-outline-primary btn-sm" onclick="enableMeasurement('{{ image.id }}')" title="Measure distance">
                                                                        <i class="fas fa-ruler me-1"></i>Measure
                                                                    </button>
                                                                </div>
                                                                <div class="btn-group me-2" role="group" aria-label="Edit">
                                                                    <button class="btn btn-outline-secondary btn-sm" onclick="undoLastAnnotation('{{ image.id }}')" title="Undo last">
                                                                        <i class="fas fa-undo me-1"></i>Undo
                                                                    </button>
                                                                    <button class="btn btn-outline-warning btn-sm" onclick="clearAnnotations('{{ image.id }}')" title="Clear all annotations for this image">
                                                                        <i class="fas fa-eraser me-1"></i>Clear
                                                                    </button>
                                                                </div>
                                                                <div class="btn-group" role="group" aria-label="Save">
                                                                    <button class="btn btn-success btn-sm" onclick="saveAnnotations('{{ image.id }}')" title="Save measurements & notes">
                                                                        <i class="fas fa-save me-1"></i>Save
                                                                    </button>
                                                                    <button class="btn btn-primary btn-sm" onclick="saveAnnotationPreview('{{ image.id }}')" title="Export preview image">
                                                                        <i class="fas fa-download me-1"></i>Save Preview
                                                                    </button>
                                                                </div>
                                                            </div>
                                                            <div class="mt-3">
                                                                <h6 class="mb-2">Drawing Notes</h6>
                                                                <div id="drawing-notes-editor-{{ image.id }}" class="list-group small">
                                                                    <!-- Drawing notes editor items will render here -->
                                                                </div>
                                                            </div>
                                                            <div class="annotation-preview mt-4">
                                                                <h6 class="mb-3">
                                                                    Annotation Preview
                                                                    <button class="btn btn-outline-primary btn-sm float-end" onclick="saveAnnotationPreview('{{ image.id }}')">
                                                                        <i class="fas fa-download"></i> Save Preview
                                                                    </button>
                                                                </h6>
                                                                <div class="card">
                                                                    <div class="card-body">
                                                                        <div class="mb-3">
                                                                            <label for="notes-{{ image.id }}" class="form-label">Notes:</label>
                                                                            <textarea class="form-control" id="notes-{{ image.id }}" rows="3" placeholder="Add any additional notes here..."></textarea>
                                                                        </div>
                                                                        <div id="annotation-preview-{{ image.id }}">
                                                                            <!-- Annotation preview will be displayed here -->
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        <input type="hidden" id="image-url-{{ image.id }}" value="{{ image.image.url }}">
                                    </div>
                                    {% endif %}
                                {% endfor %}
                            </div>
                            {% endif %}
                        {% endfor %}
                    {% else %}
                        <p class="text-center">No examinations found for this patient.</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
<script>
    const canvases = {};
    const measurements = {};
    const undoStack = {};
    const drawingNotes = {}; // Stores notes for freehand drawings per imageId
    const measurementCounters = {}; // Per-image line numbering
    const drawingCounters = {}; // Per-image drawing numbering
    let isDrawing = false;
    let isMeasuring = false;
    let startPoint = null;

    // Procedure-specific measurement fields
    const procedureFields = {
        pelvic: [
            { id: 'uterus_length', label: 'Uterus Length (cm)', type: 'measurement' },
            { id: 'uterus_width', label: 'Uterus Width (cm)', type: 'measurement' },
            { id: 'endometrial_thickness', label: 'Endometrial Thickness (mm)', type: 'measurement' },
            { id: 'right_ovary_location', label: 'Right Ovary Location', type: 'location' },
            { id: 'left_ovary_location', label: 'Left Ovary Location', type: 'location' }
        ],
        abdominal: [
            { id: 'liver_size', label: 'Liver Size (cm)', type: 'measurement' },
            { id: 'liver_location', label: 'Liver Location', type: 'location' },
            { id: 'gallbladder_location', label: 'Gallbladder Location', type: 'location' },
            { id: 'spleen_size', label: 'Spleen Size (cm)', type: 'measurement' },
            { id: 'kidney_right_size', label: 'Right Kidney Size (cm)', type: 'measurement' },
            { id: 'kidney_left_size', label: 'Left Kidney Size (cm)', type: 'measurement' }
        ],
        breast: [
            { id: 'mass_location', label: 'Mass Location', type: 'location' },
            { id: 'mass_size', label: 'Mass Size (cm)', type: 'measurement' },
            { id: 'distance_from_nipple', label: 'Distance from Nipple (cm)', type: 'measurement' }
        ],
        thyroid: [
            { id: 'right_lobe_size', label: 'Right Lobe Size (cm)', type: 'measurement' },
            { id: 'left_lobe_size', label: 'Left Lobe Size (cm)', type: 'measurement' },
            { id: 'nodule_location', label: 'Nodule Location', type: 'location' },
            { id: 'nodule_size', label: 'Nodule Size (mm)', type: 'measurement' }
        ],
        prostate: [
            { id: 'prostate_length', label: 'Prostate Length (cm)', type: 'measurement' },
            { id: 'prostate_width', label: 'Prostate Width (cm)', type: 'measurement' },
            { id: 'prostate_height', label: 'Prostate Height (cm)', type: 'measurement' },
            { id: 'prostate_volume', label: 'Prostate Volume (cc)', type: 'measurement' },
            { id: 'prostate_location', label: 'Prostate Location', type: 'location' }
        ],
        obstetric: [
            { id: 'gestational_age', label: 'Gestational Age (weeks)', type: 'measurement' },
            { id: 'crown_rump_length', label: 'Crown-Rump Length (cm)', type: 'measurement' },
            { id: 'biparietal_diameter', label: 'Biparietal Diameter (cm)', type: 'measurement' },
            { id: 'femur_length', label: 'Femur Length (cm)', type: 'measurement' },
            { id: 'amniotic_fluid_index', label: 'Amniotic Fluid Index (cm)', type: 'measurement' }
        ],
        transvaginal: [
            { id: 'uterus_length', label: 'Uterus Length (cm)', type: 'measurement' },
            { id: 'uterus_width', label: 'Uterus Width (cm)', type: 'measurement' },
            { id: 'endometrial_thickness', label: 'Endometrial Thickness (mm)', type: 'measurement' },
            { id: 'right_ovary_size', label: 'Right Ovary Size (cm)', type: 'measurement' },
            { id: 'left_ovary_size', label: 'Left Ovary Size (cm)', type: 'measurement' }
        ],
        scrotal: [
            { id: 'right_testis_length', label: 'Right Testis Length (cm)', type: 'measurement' },
            { id: 'right_testis_width', label: 'Right Testis Width (cm)', type: 'measurement' },
            { id: 'left_testis_length', label: 'Left Testis Length (cm)', type: 'measurement' },
            { id: 'left_testis_width', label: 'Left Testis Width (cm)', type: 'measurement' },
            { id: 'epididymis_location', label: 'Epididymis Location', type: 'location' }
        ],
        doppler: [
            { id: 'peak_systolic_velocity', label: 'Peak Systolic Velocity (cm/s)', type: 'measurement' },
            { id: 'end_diastolic_velocity', label: 'End Diastolic Velocity (cm/s)', type: 'measurement' },
            { id: 'resistive_index', label: 'Resistive Index', type: 'measurement' },
            { id: 'pulsatility_index', label: 'Pulsatility Index', type: 'measurement' }
        ],
        other: [
            { id: 'general_measurements', label: 'General Measurements (cm)', type: 'measurement' },
            { id: 'abnormal_findings', label: 'Abnormal Findings Location', type: 'location' },
            { id: 'additional_notes', label: 'Additional Notes', type: 'text' }
        ]
    };

    document.addEventListener('DOMContentLoaded', function() {
        // Initialize loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (!loadingIndicator) {
            console.error('Loading indicator not found');
            return;
        }

        // Initialize all canvases
        const canvasElements = document.querySelectorAll('[id^="canvas-"]');
        canvasElements.forEach(canvasElement => {
            const imageId = canvasElement.id.split('-')[1];
            try {
                console.log('Initializing canvas for image ' + imageId);
                initCanvas(imageId);
                
                // Automatically load procedure fields based on the exam's procedure type
                const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
                if (procedureTypeHidden && procedureTypeHidden.value) {
                    loadProcedureFields(imageId);
                }
                loadSavedAnnotations(imageId);
            } catch (error) {
                console.error('Error initializing canvas for image ' + imageId + ':', error);
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
            }
        });

        setupDragAndDrop();
        setupFormSubmission();
    });

    function lockObjectInteraction(obj) {
        if (!obj) return;
        obj.set({
            hasControls: false,
            lockMovementX: true,
            lockMovementY: true,
            lockRotation: true,
            lockScalingX: true,
            lockScalingY: true
        });
    }

    // Live update preview on notes typing
    document.addEventListener('DOMContentLoaded', function() {
        const noteTextareas = document.querySelectorAll('textarea[id^="notes-"]');
        noteTextareas.forEach(function(el) {
            el.addEventListener('input', function() {
                const imgId = this.id.split('-')[1];
                updateMeasurementSummary(imgId);
            });
        });
    });

    function setupDragAndDrop() {
        const dragDropZone = document.getElementById('dragDropZone');
        if (!dragDropZone) return;  // Skip if element doesn't exist

        const imageInput = document.getElementById('imageInput');
        const selectedFileName = document.querySelector('.selected-file-name');
        if (!imageInput || !selectedFileName) return;

        imageInput.addEventListener('change', function(e) {
            if (this.files && this.files[0]) {
                selectedFileName.textContent = this.files[0].name;
                previewImage(this.files[0]);
            }
        });

        dragDropZone.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.style.borderColor = '#0d6efd';
        });

        dragDropZone.addEventListener('dragleave', function(e) {
            e.preventDefault();
            this.style.borderColor = '#ccc';
        });

        dragDropZone.addEventListener('drop', function(e) {
            e.preventDefault();
            this.style.borderColor = '#ccc';
            
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                imageInput.files = e.dataTransfer.files;
                selectedFileName.textContent = e.dataTransfer.files[0].name;
                previewImage(e.dataTransfer.files[0]);
            }
        });
    }

    function setupFormSubmission() {
        const uploadForm = document.getElementById('uploadForm');
        if (!uploadForm) return;  // Skip if form doesn't exist

        uploadForm.addEventListener('submit', function(e) {
            e.preventDefault();
            
            const imageInput = document.getElementById('imageInput');
            const examSelect = document.getElementById('examSelect');

            if (!imageInput || !imageInput.files || !imageInput.files[0]) {
                alert('Please select an image to upload');
                return;
            }

            if (!examSelect || !examSelect.value) {
                alert('Please select an examination');
                return;
            }

            // Show loading indicator
            const loadingIndicator = document.getElementById('loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'block';
            }
            
            this.submit();
        });
    }

    function loadSavedAnnotations(imageId) {
        fetch(`/api/exams/${imageId}/annotations/`)
            .then(response => response.json())
            .then(data => {
                if (data.annotations) {
                    const canvas = canvases[imageId];
                    canvas.loadFromJSON(data.annotations, function() {
                        canvas.renderAll();
                        // Restore measurements from saved annotations
                        const objects = canvas.getObjects();
                        measurements[imageId] = {};
                        objects.forEach(obj => {
                            if (obj.type === 'text' && obj.measurementId) {
                                measurements[imageId][obj.measurementId] = obj.text;
                                lockObjectInteraction(obj);
                            }
                            if (obj.type === 'path' && obj.drawingId) {
                                lockObjectInteraction(obj);
                            }
                            if (obj.type === 'text' && obj.labelType) {
                                lockObjectInteraction(obj);
                            }
                        });
                        
                        // Restore notes if they exist
                        if (data.notes) {
                            const notesTextarea = document.getElementById(`notes-${imageId}`);
                            if (notesTextarea) {
                                notesTextarea.value = data.notes;
                            }
                        }

                        // Restore drawing notes if they exist
                        if (data.drawing_notes) {
                            drawingNotes[imageId] = data.drawing_notes || {};
                        }

                        // Restore on-image measurement notes if provided
                        if (data.on_image_measurements && Array.isArray(data.on_image_measurements)) {
                            data.on_image_measurements.forEach(entry => {
                                if (!measurements[imageId]) measurements[imageId] = {};
                                if (entry && entry.id) {
                                    if (entry.note) {
                                        measurements[imageId][entry.id] = { value: entry.value || '', note: entry.note };
                                    } else {
                                        measurements[imageId][entry.id] = entry.value || '';
                                    }
                                }
                            });
                        }
                        
                        renumberAnnotations(imageId);
                        renderDrawingNotesEditor(imageId);
                        updateMeasurementSummary(imageId);
                    });
                }
            })
            .catch(error => console.error('Error loading annotations:', error));
    }

    function initCanvas(imageId) {
        const loadingIndicator = document.getElementById('loading-indicator');
        const canvasContainer = document.getElementById(`canvas-${imageId}`);
        
        if (!canvasContainer) {
            console.error(`Canvas container not found for image ${imageId}`);
            return;
        }

        loadingIndicator.style.display = 'block';

        // Dispose of existing canvas if it exists
        if (canvases[imageId]) {
            canvases[imageId].dispose();
        }

        const canvas = new fabric.Canvas(`canvas-${imageId}`, {
            selection: true,
            preserveObjectStacking: true,
            isDrawingMode: false
        });
        
        canvases[imageId] = canvas;
        measurements[imageId] = {};
        drawingNotes[imageId] = {};
        undoStack[imageId] = [];
        
        // Load the ultrasound image
        const imageUrl = document.getElementById(`image-url-${imageId}`).value;
        
        fabric.Image.fromURL(imageUrl, function(img) {
            if (!img) {
                console.error(`Failed to load image for ${imageId}`);
                loadingIndicator.style.display = 'none';
                return;
            }

            const scale = Math.min(
                canvas.width / img.width,
                canvas.height / img.height
            );
            
            img.scale(scale);
            canvas.setBackgroundImage(img, function() {
                canvas.renderAll();
                loadingIndicator.style.display = 'none';
            }, {
                originX: 'center',
                originY: 'center',
                left: canvas.width / 2,
                top: canvas.height / 2
            });
        }, null, {
            crossOrigin: 'anonymous'
        });

        // Set up drawing brush
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.width = 2;
        canvas.freeDrawingBrush.color = '#ff0000';

        // Capture freehand drawings and attach optional notes
        canvas.on('path:created', function(evt) {
            const path = evt.path;
            if (!path) return;
            // Assign an id to this drawing
            const drawingId = `drawing_${Date.now()}_${Math.floor(Math.random()*1000)}`;
            path.drawingId = drawingId;
            lockObjectInteraction(path);
            // Add label near drawing start point
            const bbox = path.getBoundingRect(true);
            const number = getNextDrawingNumber(imageId);
            const label = new fabric.Text(`Draw ${number}`, {
                left: bbox.left,
                top: bbox.top - 14,
                fontSize: 13,
                fill: '#0d6efd',
                selectable: false,
                labelType: 'draw_label',
                associatedId: drawingId
            });
            lockObjectInteraction(label);
            canvas.add(label);
            if (!drawingNotes[imageId]) {
                drawingNotes[imageId] = {};
            }
            drawingNotes[imageId][drawingId] = drawingNotes[imageId][drawingId] || '';
            saveToUndoStack(imageId);
            renderDrawingNotesEditor(imageId);
            updateMeasurementSummary(imageId);
        });

        // Mouse down event
        canvas.on('mouse:down', function(options) {
            if (isMeasuring) {
                startPoint = canvas.getPointer(options.e);

                // Clear any previous temp preview artifacts
                if (canvas.__tempLine) {
                    canvas.remove(canvas.__tempLine);
                    canvas.__tempLine = null;
                }
                if (canvas.__tempText) {
                    canvas.remove(canvas.__tempText);
                    canvas.__tempText = null;
                }

                const circle = new fabric.Circle({
                    radius: 3,
                    fill: '#ff0000',
                    left: startPoint.x,
                    top: startPoint.y,
                    selectable: false,
                    originX: 'center',
                    originY: 'center'
                });
                canvas.add(circle);
            }
        });

        // Mouse move event with live preview
        canvas.on('mouse:move', function(options) {
            if (isMeasuring && startPoint) {
                const currentPoint = canvas.getPointer(options.e);

                // Create or update the preview line
                if (!canvas.__tempLine) {
                    canvas.__tempLine = new fabric.Line([
                        startPoint.x,
                        startPoint.y,
                        currentPoint.x,
                        currentPoint.y
                    ], {
                        stroke: '#ff0000',
                        strokeWidth: 2,
                        selectable: false,
                        originX: 'center',
                        originY: 'center'
                    });
                    canvas.add(canvas.__tempLine);
                } else {
                    canvas.__tempLine.set({ x2: currentPoint.x, y2: currentPoint.y });
                }

                // Calculate distance (same conversion used on finalize: 1px = 0.1mm)
                const pixelDistance = Math.sqrt(
                    Math.pow(currentPoint.x - startPoint.x, 2) +
                    Math.pow(currentPoint.y - startPoint.y, 2)
                );
                const mmDistance = (pixelDistance * 0.1).toFixed(1);

                // Midpoint for label positioning
                const midX = (startPoint.x + currentPoint.x) / 2;
                const midY = (startPoint.y + currentPoint.y) / 2 - 10;

                // Create or update the preview text
                if (!canvas.__tempText) {
                    canvas.__tempText = new fabric.Text(`${mmDistance} mm`, {
                        left: midX,
                        top: midY,
                        fontSize: 14,
                        fill: '#ff0000',
                        selectable: false,
                        originX: 'center',
                        originY: 'center'
                    });
                    canvas.add(canvas.__tempText);
                } else {
                    canvas.__tempText.set({ left: midX, top: midY, text: `${mmDistance} mm` });
                }

                canvas.renderAll();
            }
        });

        // Mouse up event
        canvas.on('mouse:up', function(options) {
            if (isMeasuring && startPoint) {
                const endPoint = canvas.getPointer(options.e);
                
                // Calculate distance and convert to appropriate units (assuming 1px = 0.1mm)
                const pixelDistance = Math.sqrt(
                    Math.pow(endPoint.x - startPoint.x, 2) +
                    Math.pow(endPoint.y - startPoint.y, 2)
                );
                const mmDistance = (pixelDistance * 0.1).toFixed(1);
                
                // Final measurement label
                const measurementId = `measurement_${Date.now()}`;
                const finalText = new fabric.Text(
                    `${mmDistance} mm`,
                    {
                        left: (startPoint.x + endPoint.x) / 2,
                        top: (startPoint.y + endPoint.y) / 2 - 10,
                        fontSize: 14,
                        fill: '#ff0000',
                        selectable: true,
                        measurementId: measurementId,
                        originX: 'center',
                        originY: 'center'
                    }
                );
                lockObjectInteraction(finalText);
                canvas.add(finalText);

                // Add measurement line label
                const labelNumber = getNextMeasurementNumber(imageId);
                const labelText = new fabric.Text(`Line ${labelNumber}`, {
                    left: (startPoint.x + endPoint.x) / 2,
                    top: (startPoint.y + endPoint.y) / 2 - 28,
                    fontSize: 13,
                    fill: '#0d6efd',
                    selectable: false,
                    labelType: 'line_label',
                    associatedId: measurementId,
                    originX: 'center',
                    originY: 'center'
                });
                lockObjectInteraction(labelText);
                canvas.add(labelText);
                
                // Store measurement
                // Ask user to add a note/label for this measurement
                let measurementNote = '';
                try {
                    measurementNote = window.prompt('Enter note/label for this measurement (optional):', '');
                } catch (e) {
                    measurementNote = '';
                }
                if (!measurements[imageId]) {
                    measurements[imageId] = {};
                }
                if (measurementNote && measurementNote.trim()) {
                    measurements[imageId][measurementId] = { value: `${mmDistance} mm`, note: measurementNote.trim() };
                } else {
                    measurements[imageId][measurementId] = `${mmDistance} mm`;
                }
                
                // Add end point circle
                const circle = new fabric.Circle({
                    radius: 3,
                    fill: '#ff0000',
                    left: endPoint.x,
                    top: endPoint.y,
                    selectable: false,
                    originX: 'center',
                    originY: 'center'
                });
                lockObjectInteraction(circle);
                canvas.add(circle);

                // Remove temp preview text but keep the line as the final line
                if (canvas.__tempText) {
                    canvas.remove(canvas.__tempText);
                    canvas.__tempText = null;
                }
                // Clear reference so future moves create a new preview line
                canvas.__tempLine = null;
                
                startPoint = null;
                saveToUndoStack(imageId);
                renumberAnnotations(imageId);
                updateMeasurementSummary(imageId);
            }
        });

        // Add keyboard event for delete
        document.addEventListener('keyup', function(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length > 0) {
                    activeObjects.forEach(obj => {
                        canvas.remove(obj);
                        if (obj.measurementId && measurements[imageId]) {
                            delete measurements[imageId][obj.measurementId];
                        }
                        if (obj.drawingId && drawingNotes[imageId]) {
                            delete drawingNotes[imageId][obj.drawingId];
                        }
                    });
                    canvas.discardActiveObject();
                    canvas.renderAll();
                    saveToUndoStack(imageId);
                    updateMeasurementSummary(imageId);
                }
            }
        });

        return canvas;
    }

    function loadProcedureFields(examId) {
        const procedureTypeHidden = document.getElementById(`procedure-type-${examId}`);
        if (!procedureTypeHidden) {
            console.error('Procedure type hidden field not found');
            return;
        }

        // Get and clean up the procedure type value
        let procedureType = procedureTypeHidden.value.toLowerCase()
            .replace(/\s+ultrasound/i, '')  // Remove "ultrasound" and spaces before it
            .replace(/\s+/g, '')  // Remove all spaces
            .trim();
            
        console.log('Procedure type from hidden field:', procedureTypeHidden.value);
        console.log('Cleaned procedure type:', procedureType);
        
        const fieldsContainer = document.getElementById(`procedure-fields-${examId}`);
        if (!fieldsContainer) {
            console.error('Fields container not found');
            return;
        }

        const fields = procedureFields[procedureType] || [];
        console.log('Found fields:', fields);
        
        let html = '';
        fields.forEach(field => {
            html += `
                <div class="mb-3">
                    <label class="form-label">${field.label}:</label>
                    ${field.type === 'location' ? `
                        <div class="input-group">
                            <input type="text" class="form-control" id="${field.id}-${examId}" placeholder="Click on image to set location">
                            <button class="btn btn-outline-primary" onclick="startLocationSelection('${examId}', '${field.id}')">
                                Set Location
                            </button>
                        </div>
                    ` : field.type === 'text' ? `
                        <textarea class="form-control" id="${field.id}-${examId}" rows="2" 
                                  onchange="updateMeasurement('${examId}', '${field.id}', this.value)" 
                                  placeholder="Enter additional notes or findings"></textarea>
                    ` : `
                        <input type="number" class="form-control" id="${field.id}-${examId}" 
                               onchange="updateMeasurement('${examId}', '${field.id}', this.value)">
                    `}
                </div>
            `;
        });
        
        fieldsContainer.innerHTML = html;
        clearAnnotations(examId);
    }

    function loadSavedMeasurements(imageId, procedureType) {
        fetch(`/api/exams/${imageId}/annotations/?type=${procedureType}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data && data.measurements) {
                    Object.entries(data.measurements).forEach(([key, value]) => {
                        const input = document.getElementById(`${key}-${imageId}`);
                        if (input) {
                            input.value = value;
                        }
                    });
                }
            })
            .catch(error => {
                console.log('Warning: Could not load saved measurements.', error);
                // Don't show error to user, just continue without loading measurements
            });
    }

    function updateMeasurement(imageId, fieldId, value) {
        if (!measurements[imageId]) {
            measurements[imageId] = {};
        }
        measurements[imageId][fieldId] = value;
        updateMeasurementSummary(imageId);
    }

    function updateMeasurementSummary(examId) {
        const procedureTypeHidden = document.getElementById(`procedure-type-${examId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        const previewContainer = document.getElementById(`annotation-preview-${examId}`);
        const fields = procedureFields[procedureType.toLowerCase().replace(/\s+ultrasound/i, '').replace(/\s+/g, '').trim()] || [];
        
        // Update annotation preview
        let previewHtml = '';
        if (procedureType) {
            previewHtml += `<h6 class="text-primary">${procedureType}</h6>`;
            
            // Group measurements and locations
            const measurementFields = fields.filter(f => f.type === 'measurement' && document.getElementById(`${f.id}-${examId}`) && document.getElementById(`${f.id}-${examId}`).value);
            const locations = fields.filter(f => f.type === 'location' && document.getElementById(`${f.id}-${examId}`) && document.getElementById(`${f.id}-${examId}`).value);
            const textFields = fields.filter(f => f.type === 'text' && document.getElementById(`${f.id}-${examId}`) && document.getElementById(`${f.id}-${examId}`).value);
            
            if (measurementFields.length > 0) {
                previewHtml += '<div class="mb-3"><strong>Measurements:</strong><ul class="mb-0">';
                measurementFields.forEach(field => {
                    const inputEl = document.getElementById(`${field.id}-${examId}`);
                    const value = inputEl ? inputEl.value : '';
                    if (value) {
                        previewHtml += `<li>${field.label}: ${value}</li>`;
                    }
                });
                previewHtml += '</ul></div>';
            }
            
            // Combined on-image annotations: Lines and Drawings with notes
            const canvas = canvases[examId];
            if (canvas) {
                const allObjects = canvas.getObjects();
                const combined = [];
                // Lines
                allObjects.forEach(obj => {
                    if (obj.type === 'text' && obj.measurementId) {
                        const mid = obj.measurementId;
                        const stored = (measurements && measurements[examId]) ? measurements[examId][mid] : null;
                        if (stored) {
                            if (typeof stored === 'string') {
                                combined.push({ kind: 'line', value: stored, note: '' });
                            } else if (stored.value) {
                                combined.push({ kind: 'line', value: stored.value, note: stored.note || '' });
                            }
                        } else if (obj.text) {
                            combined.push({ kind: 'line', value: obj.text, note: '' });
                        }
                    }
                });
                // Drawings
                allObjects.forEach(obj => {
                    if (obj.type === 'path' && obj.drawingId) {
                        const did = obj.drawingId;
                        const note = (drawingNotes && drawingNotes[examId]) ? (drawingNotes[examId][did] || '') : '';
                        combined.push({ kind: 'draw', value: '', note: note });
                    }
                });
                if (combined.length > 0) {
                    previewHtml += '<div class="mb-3"><strong>On-image Annotations:</strong><ul class="mb-0">';
                    let lineIdx = 0;
                    let drawIdx = 0;
                    combined.forEach(entry => {
                        if (entry.kind === 'line') {
                            lineIdx += 1;
                            const label = entry.note ? `${entry.value} â€” ${entry.note}` : entry.value;
                            previewHtml += `<li>Line ${lineIdx}: ${label}</li>`;
                        } else {
                            drawIdx += 1;
                            const label = entry.note ? entry.note : '(no note)';
                            previewHtml += `<li>Draw ${drawIdx}: ${label}</li>`;
                        }
                    });
                    previewHtml += '</ul></div>';
                }
            }

            if (locations.length > 0) {
                previewHtml += '<div><strong>Marked Locations:</strong><ul class="mb-0">';
                locations.forEach(field => {
                    const inputEl = document.getElementById(`${field.id}-${examId}`);
                    const value = inputEl ? inputEl.value : '';
                    if (value) {
                        previewHtml += `<li>${field.label}: ${value}</li>`;
                    }
                });
                previewHtml += '</ul></div>';
            }
            
            if (textFields.length > 0) {
                previewHtml += '<div class="mb-3"><strong>Additional Information:</strong><ul class="mb-0">';
                textFields.forEach(field => {
                    const inputEl = document.getElementById(`${field.id}-${examId}`);
                    const value = inputEl ? inputEl.value : '';
                    if (value) {
                        previewHtml += `<li>${field.label}: ${value}</li>`;
                    }
                });
                previewHtml += '</ul></div>';
            }

            // Add notes to preview if they exist
            const notesEl = document.getElementById(`notes-${examId}`);
            const notes = notesEl ? notesEl.value.trim() : '';
            if (notes) {
                previewHtml += '<div class="mt-3"><strong>Notes:</strong><p class="mb-0">' + notes.replace(/\n/g, '<br>') + '</p></div>';
            }

            if (!measurementFields.length && !locations.length && !textFields.length && !notes) {
                previewHtml += '<p class="text-muted">No measurements, locations, additional information, or notes marked yet.</p>';
            }
        } else {
            previewHtml = '<p class="text-muted">Please select a procedure type to start annotation.</p>';
        }
        
        previewContainer.innerHTML = previewHtml;
    }

    function renderDrawingNotesEditor(imageId) {
        const container = document.getElementById(`drawing-notes-editor-${imageId}`);
        if (!container) return;
        const notesMap = drawingNotes[imageId] || {};
        const canvas = canvases[imageId];
        const existingPaths = new Set((canvas ? canvas.getObjects() : []).filter(o => o.type === 'path' && o.drawingId).map(o => o.drawingId));

        // Clean up notes for deleted drawings
        Object.keys(notesMap).forEach(id => {
            if (!existingPaths.has(id)) {
                delete notesMap[id];
            }
        });

        const entries = Object.entries(notesMap);
        if (entries.length === 0) {
            container.innerHTML = '<div class="list-group-item text-muted">No drawings yet. Use Draw to add one.</div>';
            updateMeasurementSummary(imageId);
            return;
        }

        container.innerHTML = entries.map(([id, note], idx) => `
            <div class="list-group-item d-flex align-items-start" data-drawing-id="${id}">
                <div class="me-2 text-muted">${idx + 1}.</div>
                <div class="flex-grow-1">
                    <textarea class="form-control form-control-sm mb-2" rows="2" placeholder="Add note for this drawing..." oninput="updateDrawingNote('${imageId}', '${id}', this.value)">${note || ''}</textarea>
                    <div>
                        <button class="btn btn-sm btn-outline-danger" onclick="deleteDrawing('${imageId}', '${id}')"><i class="fas fa-trash-alt"></i> Remove Drawing</button>
                        <button class="btn btn-sm btn-outline-secondary ms-2" onclick="locateDrawing('${imageId}', '${id}')"><i class="fas fa-crosshairs"></i> Locate</button>
                    </div>
                </div>
            </div>
        `).join('');

        updateMeasurementSummary(imageId);
    }

    function updateDrawingNote(imageId, drawingId, value) {
        if (!drawingNotes[imageId]) drawingNotes[imageId] = {};
        drawingNotes[imageId][drawingId] = value;
        saveToUndoStack(imageId);
        updateMeasurementSummary(imageId);
    }

    function deleteDrawing(imageId, drawingId) {
        const canvas = canvases[imageId];
        if (!canvas) return;
        const targets = canvas.getObjects().filter(o => o.type === 'path' && o.drawingId === drawingId);
        targets.forEach(o => canvas.remove(o));
        if (drawingNotes[imageId]) delete drawingNotes[imageId][drawingId];
        canvas.renderAll();
        saveToUndoStack(imageId);
        renderDrawingNotesEditor(imageId);
        updateMeasurementSummary(imageId);
    }

    function locateDrawing(imageId, drawingId) {
        const canvas = canvases[imageId];
        if (!canvas) return;
        const obj = canvas.getObjects().find(o => o.type === 'path' && o.drawingId === drawingId);
        if (!obj) return;
        canvas.setActiveObject(obj);
        canvas.requestRenderAll();
        // Brief highlight by toggling opacity
        const originalOpacity = obj.opacity ?? 1;
        obj.animate('opacity', 0.3, { onChange: canvas.renderAll.bind(canvas), duration: 150, onComplete: function() {
            obj.animate('opacity', originalOpacity, { onChange: canvas.renderAll.bind(canvas), duration: 150 });
        }});
    }

    function getNextMeasurementNumber(imageId) {
        if (!measurementCounters[imageId]) measurementCounters[imageId] = 0;
        measurementCounters[imageId] += 1;
        return measurementCounters[imageId];
    }

    function getNextDrawingNumber(imageId) {
        if (!drawingCounters[imageId]) drawingCounters[imageId] = 0;
        drawingCounters[imageId] += 1;
        return drawingCounters[imageId];
    }

    function renumberAnnotations(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;
        // Reset counters
        measurementCounters[imageId] = 0;
        drawingCounters[imageId] = 0;

        // Collect items in draw order
        const items = canvas.getObjects();
        items.forEach(obj => {
            if (obj.type === 'text' && obj.labelType === 'line_label') {
                // skip, will be recalculated inline after measurement text
                canvas.remove(obj);
            }
            if (obj.type === 'text' && obj.labelType === 'draw_label') {
                canvas.remove(obj);
            }
        });

        // Recreate labels in correct order
        const freshItems = canvas.getObjects();
        freshItems.forEach(obj => {
            if (obj.type === 'text' && obj.measurementId) {
                const num = getNextMeasurementNumber(imageId);
                const label = new fabric.Text(`Line ${num}`, {
                    left: obj.left,
                    top: obj.top - 18,
                    fontSize: 13,
                    fill: '#0d6efd',
                    selectable: false,
                    labelType: 'line_label',
                    associatedId: obj.measurementId,
                    originX: 'center',
                    originY: 'center'
                });
                lockObjectInteraction(label);
                canvas.add(label);
            }
            if (obj.type === 'path' && obj.drawingId) {
                const bbox = obj.getBoundingRect(true);
                const num = getNextDrawingNumber(imageId);
                const label = new fabric.Text(`Draw ${num}`, {
                    left: bbox.left,
                    top: bbox.top - 14,
                    fontSize: 13,
                    fill: '#0d6efd',
                    selectable: false,
                    labelType: 'draw_label',
                    associatedId: obj.drawingId
                });
                lockObjectInteraction(label);
                canvas.add(label);
            }
        });
        canvas.renderAll();
    }

    function clearAnnotations(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;

        // Clear all objects except background image
        const objects = canvas.getObjects();
        objects.forEach(obj => {
            if (obj !== canvas.backgroundImage) {
                canvas.remove(obj);
            }
        });
        canvas.renderAll();
        
        // Clear measurements & drawing notes
        measurements[imageId] = {};
        drawingNotes[imageId] = {};
        undoStack[imageId] = [];
        
        // Clear input fields
        const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        if (procedureType) {
            const cleanedProcedureType = procedureType.toLowerCase()
                .replace(/\s+ultrasound/i, '')
                .replace(/\s+/g, '')
                .trim();
            const fields = procedureFields[cleanedProcedureType] || [];
            fields.forEach(field => {
                const input = document.getElementById(`${field.id}-${imageId}`);
                if (input) input.value = '';
            });
        }
        
        renderDrawingNotesEditor(imageId);
        updateMeasurementSummary(imageId);
    }

    function saveToUndoStack(imageId) {
        const canvas = canvases[imageId];
        undoStack[imageId].push({
            canvas: JSON.stringify(canvas.toJSON(['measurementId','drawingId'])),
            measurements: JSON.parse(JSON.stringify(measurements[imageId])),
            drawingNotes: JSON.parse(JSON.stringify(drawingNotes[imageId] || {}))
        });
    }

    function undoLastAnnotation(imageId) {
        if (undoStack[imageId].length > 0) {
            const canvas = canvases[imageId];
            const lastState = undoStack[imageId].pop();
            
            canvas.loadFromJSON(JSON.parse(lastState.canvas), function() {
                canvas.renderAll();
                measurements[imageId] = lastState.measurements;
                drawingNotes[imageId] = lastState.drawingNotes || {};
                renderDrawingNotesEditor(imageId);
                renumberAnnotations(imageId);
                updateMeasurementSummary(imageId);
            });
        }
    }

    function enableDrawing(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;

        isDrawing = true;
        isMeasuring = false;
        canvas.isDrawingMode = true;
        canvas.freeDrawingBrush.width = 2;
        canvas.freeDrawingBrush.color = '#ff0000';
        
        // Change cursor
        canvas.defaultCursor = 'crosshair';
        canvas.hoverCursor = 'crosshair';
    }

    function enableMeasurement(imageId) {
        const canvas = canvases[imageId];
        if (!canvas) return;

        isDrawing = false;
        isMeasuring = true;
        canvas.isDrawingMode = false;
        
        // Change cursor
        canvas.defaultCursor = 'crosshair';
        canvas.hoverCursor = 'crosshair';
    }

    function saveAnnotations(imageId) {
        const canvas = canvases[imageId];
        const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        
        if (!procedureType) {
            alert('No procedure type found. Please refresh the page and try again.');
            return;
        }
        
        // Get the cleaned procedure type for field lookup
        const cleanedProcedureType = procedureType.toLowerCase()
            .replace(/\s+ultrasound/i, '')
            .replace(/\s+/g, '')
            .trim();
        
        // Collect all measurements for the current procedure
        const measurementData = {};
        const fields = procedureFields[cleanedProcedureType] || [];
        
        fields.forEach(field => {
            const input = document.getElementById(`${field.id}-${imageId}`);
            if (input && input.value) {
                measurementData[field.id] = input.value;
            }
        });

        // Get notes
        const notes = document.getElementById(`notes-${imageId}`).value.trim();
        
        const data = {
            annotations: canvas.toJSON(['measurementId','drawingId','labelType','associatedId']),
            measurements: measurementData,
            procedure_type: procedureType,
            notes: notes,
            drawing_notes: drawingNotes[imageId] || {}
        };
        
        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'block';
        }
        
        fetch(`/api/exams/${imageId}/annotations/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify(data)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            if (data.status === 'success') {
                // Show success message
                const successMessage = document.createElement('div');
                successMessage.className = 'alert alert-success alert-dismissible fade show';
                successMessage.innerHTML = `
                    <strong>Success!</strong> Annotations, measurements, and notes saved successfully.
                    <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                `;
                const container = document.querySelector('.annotation-container');
                container.insertBefore(successMessage, container.firstChild);
                
                // Auto dismiss after 3 seconds
                setTimeout(() => {
                    successMessage.remove();
                }, 3000);
                
                updateMeasurementSummary(imageId);
            } else {
                throw new Error('Error saving annotations and measurements');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            // Show error message
            const errorMessage = document.createElement('div');
            errorMessage.className = 'alert alert-danger alert-dismissible fade show';
            errorMessage.innerHTML = `
                <strong>Error!</strong> Failed to save annotations and measurements. Please try again.
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            const container = document.querySelector('.annotation-container');
            container.insertBefore(errorMessage, container.firstChild);
            
            // Auto dismiss after 5 seconds
            setTimeout(() => {
                errorMessage.remove();
            }, 5000);
        });
    }

    // Helper function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function startLocationSelection(examId, fieldId) {
        const canvas = canvases[examId];
        if (!canvas) {
            console.error('Canvas not found');
            return;
        }

        const input = document.getElementById(`${fieldId}-${examId}`);
        if (!input) {
            console.error('Input field not found');
            return;
        }

        // Change cursor to indicate location selection mode
        canvas.defaultCursor = 'crosshair';
        
        // Remove any existing mouse:down handlers
        canvas.off('mouse:down');
        
        // Add new mouse:down handler
        canvas.on('mouse:down', function locationHandler(options) {
            const pointer = canvas.getPointer(options.e);
            addLocationMarker(examId, fieldId, pointer.x, pointer.y);
            input.value = `X: ${Math.round(pointer.x)}, Y: ${Math.round(pointer.y)}`;
            
            // Reset cursor and remove this handler after location is set
            canvas.defaultCursor = 'default';
            canvas.off('mouse:down', locationHandler);
            
            // Update measurements
            updateMeasurement(examId, fieldId, input.value);
        });
    }

    function addLocationMarker(examId, fieldId, x, y) {
        const canvas = canvases[examId];
        if (!canvas) {
            console.error('Canvas not found');
            return;
        }

        // Create marker circle
        const circle = new fabric.Circle({
            left: x - 5,
            top: y - 5,
            radius: 5,
            fill: 'red',
            stroke: 'white',
            strokeWidth: 2,
            selectable: false
        });
        
        // Create label
        const labelText = fieldId.replace(/_/g, ' ').replace(/location$/, '').trim();
        const label = new fabric.Text(labelText, {
            left: x + 10,
            top: y - 10,
            fontSize: 14,
            fill: 'red',
            selectable: false
        });
        
        // Group circle and label
        const group = new fabric.Group([circle, label], {
            id: fieldId,
            selectable: false
        });
        
        // Remove existing marker for this field if it exists
        const existingObjects = canvas.getObjects().filter(obj => obj.id === fieldId);
        existingObjects.forEach(obj => canvas.remove(obj));
        
        // Add new marker
        canvas.add(group);
        canvas.renderAll();
        
        // Save to undo stack
        saveToUndoStack(examId);
    }

    function saveAnnotationPreview(imageId) {
        const canvas = canvases[imageId];
        const procedureTypeHidden = document.getElementById(`procedure-type-${imageId}`);
        const procedureType = procedureTypeHidden ? procedureTypeHidden.value : '';
        
        if (!canvas || !procedureType) {
            alert('Please ensure you have an image and procedure type available.');
            return;
        }

        // Show loading indicator
        const loadingIndicator = document.getElementById('loading-indicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = 'block';
        }

        // Get the notes
        const notes = document.getElementById(`notes-${imageId}`).value.trim();

        // Calculate required height for notes
        const lineHeight = 20;
        const noteLines = notes ? notes.split('\n').length : 0;
        const extraHeight = Math.max(150, (noteLines * lineHeight) + 100); // Minimum 150px or more based on notes

        // Create a temporary canvas to combine the image and annotations
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height + extraHeight;
        const ctx = tempCanvas.getContext('2d');

        // Clear the entire canvas with white background
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);

        // Draw the main canvas content
        ctx.drawImage(canvas.getElement(), 0, 0);

        // Add white background for text area
        ctx.fillStyle = 'white';
        ctx.fillRect(0, canvas.height, canvas.width, extraHeight);

        // Set text properties
        ctx.fillStyle = 'black';
        ctx.font = '14px Arial';
        
        // Get all measurements and locations
        const cleanedProcedureType = procedureType.toLowerCase()
            .replace(/\s+ultrasound/i, '')
            .replace(/\s+/g, '')
            .trim();
        const fields = procedureFields[cleanedProcedureType] || [];
        let yPos = canvas.height + 30; // Start a bit lower from the image
        
        // Add title
        ctx.font = 'bold 16px Arial';
        ctx.fillText(`${procedureType} Annotations`, 10, yPos);
        yPos += 25;
        ctx.font = '14px Arial';

        // Add combined on-image annotations (lines + drawings)
        const allObjects = canvas.getObjects();
        const combined = [];
        // Lines
        allObjects.forEach(obj => {
            if (obj.type === 'text' && obj.measurementId) {
                const mid = obj.measurementId;
                const stored = (measurements && measurements[imageId]) ? measurements[imageId][mid] : null;
                if (stored) {
                    if (typeof stored === 'string') {
                        combined.push({ kind: 'line', value: stored, note: '' });
                    } else if (stored.value) {
                        combined.push({ kind: 'line', value: stored.value, note: stored.note || '' });
                    }
                } else if (obj.text) {
                    combined.push({ kind: 'line', value: obj.text, note: '' });
                }
            }
        });
        // Drawings
        allObjects.forEach(obj => {
            if (obj.type === 'path' && obj.drawingId) {
                const did = obj.drawingId;
                const note = (drawingNotes && drawingNotes[imageId]) ? (drawingNotes[imageId][did] || '') : '';
                combined.push({ kind: 'draw', value: '', note: note });
            }
        });
        if (combined.length > 0) {
            ctx.fillText('On-image Annotations:', 10, yPos);
            yPos += 20;
            let lineIdx = 0;
            let drawIdx = 0;
            combined.forEach(entry => {
                if (entry.kind === 'line') {
                    lineIdx += 1;
                    const label = entry.note ? `${entry.value} â€” ${entry.note}` : entry.value;
                    ctx.fillText(`Line ${lineIdx}: ${label}`, 20, yPos);
                    yPos += 20;
                } else {
                    drawIdx += 1;
                    const label = entry.note ? entry.note : '(no note)';
                    ctx.fillText(`Draw ${drawIdx}: ${label}`, 20, yPos);
                    yPos += 20;
                }
            });
        }

        // Add locations
        const locations = fields.filter(f => f.type === 'location' && document.getElementById(`${f.id}-${imageId}`).value);
        if (locations.length > 0) {
            yPos += 10;
            ctx.fillText('Marked Locations:', 10, yPos);
            yPos += 20;
            locations.forEach(field => {
                const value = document.getElementById(`${field.id}-${imageId}`).value;
                if (value) {
                    ctx.fillText(`${field.label}: ${value}`, 20, yPos);
                    yPos += 20;
                }
            });
        }

        // Add drawing notes if they exist
        const drawingEntries = [];
        const drawingMap = drawingNotes[imageId] || {};
        const canvasObjects = canvas.getObjects();
        canvasObjects.forEach(obj => {
            if (obj.type === 'path' && obj.drawingId && drawingMap[obj.drawingId]) {
                drawingEntries.push(drawingMap[obj.drawingId]);
            }
        });
        if (drawingEntries.length > 0) {
            yPos += 10;
            ctx.fillText('Drawing Notes:', 10, yPos);
            yPos += 20;
            drawingEntries.forEach(n => {
                // wrap drawing note text as well
                const words = String(n).split(' ');
                let currentLine = '';
                const maxWidth = canvas.width - 40;
                words.forEach(word => {
                    const testLine = currentLine + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine !== '') {
                        ctx.fillText(currentLine, 20, yPos);
                        currentLine = word + ' ';
                        yPos += lineHeight;
                    } else {
                        currentLine = testLine;
                    }
                });
                if (currentLine) {
                    ctx.fillText(currentLine.trim(), 20, yPos);
                    yPos += lineHeight;
                }
            });
        }

        // Add notes if they exist
        if (notes) {
            yPos += 20;
            ctx.font = 'bold 14px Arial';
            ctx.fillText('Notes:', 10, yPos);
            ctx.font = '14px Arial';
            yPos += 20;
            
            // Split notes into lines and render each line
            const noteLines = notes.split('\n');
            noteLines.forEach(line => {
                // Handle long lines by wrapping text
                const words = line.split(' ');
                let currentLine = '';
                const maxWidth = canvas.width - 40; // Leave some margin

                words.forEach(word => {
                    const testLine = currentLine + word + ' ';
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine !== '') {
                        ctx.fillText(currentLine, 20, yPos);
                        currentLine = word + ' ';
                        yPos += lineHeight;
                    } else {
                        currentLine = testLine;
                    }
                });
                
                if (currentLine) {
                    ctx.fillText(currentLine.trim(), 20, yPos);
                    yPos += lineHeight;
                }
            });
        }

        // Convert the canvas to a data URL
        const dataUrl = tempCanvas.toDataURL('image/png');

        // Build on-image measurements payload with notes
        const onImagePayload = [];
        Object.entries(measurements[imageId] || {}).forEach(([id, val]) => {
            if (typeof val === 'string') {
                onImagePayload.push({ id, value: val, note: '' });
            } else if (val && typeof val === 'object') {
                onImagePayload.push({ id, value: val.value || '', note: val.note || '' });
            }
        });

        // Send to server
        fetch(`/api/exams/${imageId}/save-preview/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                image_data: dataUrl,
                procedure_type: cleanedProcedureType,
                annotations: canvas.toJSON(['measurementId','drawingId','labelType','associatedId']),
                preview_html: document.getElementById(`annotation-preview-${imageId}`).innerHTML,
                on_image_measurements: onImagePayload,
                notes: notes,
                drawing_notes: drawingNotes[imageId] || {}
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .then(data => {
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            
            if (data.status === 'success') {
                // Show brief success message
                const successMessage = document.createElement('div');
                successMessage.className = 'alert alert-success';
                successMessage.textContent = 'Annotation preview saved successfully. Redirecting...';
                document.body.insertBefore(successMessage, document.body.firstChild);
                
                // Redirect to patient detail page after a brief delay
                setTimeout(() => {
                    window.location.href = `/patient/${data.patient_id}/`;
                }, 1500);
            } else {
                throw new Error(data.message || 'Error saving preview');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
            
            // Show error message
            const errorMessage = document.createElement('div');
            errorMessage.className = 'alert alert-danger alert-dismissible fade show';
            errorMessage.innerHTML = `
                <strong>Error!</strong> Failed to save annotation preview. Please try again.
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            const container = document.querySelector('.annotation-container');
            container.insertBefore(errorMessage, container.firstChild);

            // Auto dismiss after 5 seconds
            setTimeout(() => {
                errorMessage.remove();
            }, 5000);
        });
    }
</script>
{% endblock %} 